#!/usr/bin/env python3
# SPDX-FileCopyrightText: Levin Baumann <github@17d.me>
#
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# generate_colors.py - Generate Lua table of line colors from Traewelling line-colors CSV
# adapted for VBN GTFS feed by luna-cant-code (GitHub)


import csv
import logging
import os
import re
import sys
import requests
from typing import Dict, Any

URL = "https://raw.githubusercontent.com/Traewelling/line-colors/refs/heads/main/line-colors-VBN.csv"
OUTPUT = "scripts/de-VBN-colors.lua"

HEX_RE = re.compile(r"^[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$")


def fetch_csv(url: str) -> str:
    logging.info("Fetching CSV from %s", url)
    try:
        resp = requests.get(url, timeout=15)
        resp.raise_for_status()
        return resp.text
    except requests.RequestException:
        logging.exception("Error while fetching CSV from %s", url)
        raise


def _find_key(row_keys, desired: str):
    """Return the actual key in row_keys whose stripped form equals desired.

    This makes the parser tolerant to CSVs that have leading/trailing spaces
    in header names (e.g. ' delfiAgencyName').
    """
    for k in row_keys:
        if k is not None and k.strip() == desired:
            return k
    return None


def normalize_hex(s: str) -> str:
    if s is None:
        return ""
    s = s.strip().lstrip('#')
    if s == "":
        return ""
    if len(s) == 3 and HEX_RE.match(s):
        # expand short form like 'f0c' -> 'ff00cc'
        return ''.join([c * 2 for c in s]).lower()
    if len(s) == 6 and HEX_RE.match(s):
        return s.lower()
    # invalid value
    logging.warning("Invalid hex color encountered: %r", s)
    return ""


def parse_colors(csv_text: str) -> Dict[str, Dict[str, Dict[str, Any]]]:
    lines = csv_text.splitlines()
    reader = csv.DictReader(lines, skipinitialspace=False)

    # Identify header keys we need (tolerate leading/trailing whitespace)
    header = reader.fieldnames or []
##    key_agency = _find_key(header, 'delfiAgencyName') or _find_key(header, ' delfiAgencyName') // left for transition purposes
    key_agency = _find_key(header, 'GTFSAgencyName') or _find_key(header, ' GTFSAgencyName')
    key_line = _find_key(header, 'lineName')
    key_bg = _find_key(header, 'backgroundColor')
    key_text = _find_key(header, 'textColor')
    key_border = _find_key(header, 'borderColor')

    if not (key_agency and key_line and key_bg and key_text):
        logging.error("CSV is missing expected headers. Found: %r", header)
        raise ValueError("CSV missing required headers")

    colors: Dict[str, Dict[str, Dict[str, Any]]] = {}

    for row in reader:
        agency = (row.get(key_agency) or "").strip()
        line_name = (row.get(key_line) or "").strip()
        line_name = line_name.replace(" ", "")
        background = normalize_hex(row.get(key_bg) or "")
        text = normalize_hex(row.get(key_text) or "")
        border = normalize_hex(row.get(key_border) or "")

        # Skip rows without a line name or delfi agency
        if line_name == "" or agency == "":
            continue

        # If background is white or missing, use border color if available,
        # since motis only supports background and text colors
        if border and (background == "" or background.lower() == "ffffff"):
            background = border
            text = "ffffff"

        # If any color is still missing, skip this entry
        if background == "" or text == "":
            logging.warning("Skipping entry for agency %r, line %r due to missing colors", agency, line_name)
            continue

        colors.setdefault(agency, {})[line_name] = {
            'color': background,
            'textColor': text
        }

    return colors


def _escape_lua_string(s: str) -> str:
    return s.replace('\\', '\\\\').replace('"', '\\"')


def write_lua_table(colors: Dict[str, Dict[str, Dict[str, Any]]], out_path: str) -> None:
    logging.info("Writing Lua table to %s", out_path)
    dirpath = os.path.dirname(out_path)
    if dirpath and not os.path.exists(dirpath):
        os.makedirs(dirpath)

    with open(out_path, 'w', encoding='utf-8') as f:
        f.write('-- autogenerated by generate_colors.py\n')
        f.write('-- SPDX-FileCopyrightText: contributors of https://github.com/Traewelling/line-colors\n')
        f.write('-- SPDX-License-Identifier: CC0-1.0\n\n')
        f.write('local colors = {\n')

        # Sort agencies for deterministic output
        for agency in sorted(colors.keys()):
            safe_agency = _escape_lua_string(agency)
            f.write(f'    ["{safe_agency}"] = {{\n')
            for line_name in sorted(colors[agency].keys()):
                safe_line = _escape_lua_string(line_name)
                info = colors[agency][line_name]
                # convert hex string to 0x... numeric literal
                bg = info.get('color', '000000')
                text = info.get('textColor', '000000')
                # ensure 6-digit hex
                if len(bg) == 3:
                    bg = ''.join([c * 2 for c in bg])
                if len(text) == 3:
                    text = ''.join([c * 2 for c in text])

                f.write(f'        ["{safe_line}"] = {{ color = 0x{bg}, text_color = 0x{text} }},\n')
            f.write('    },\n')

        f.write('}\n')
        f.write('return colors\n')

    logging.info("Wrote %d agencies to %s", len(colors), out_path)


def main():
    logging.basicConfig(level=logging.WARNING,
                        format='%(levelname)s: %(message)s')

    try:
        csv_text = fetch_csv(URL)
        colors = parse_colors(csv_text)
        write_lua_table(colors, OUTPUT)
    except Exception as e:
        logging.exception("Failed to generate colors: %s", e)
        return 2

    return 0


if __name__ == '__main__':
    sys.exit(main())
